<h1 style="font-size: 60px; font-weight: 900;
           font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
           text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);">
  <span>🚀</span>
  <span style="background: linear-gradient(135deg, #8ec5fc, #e0c3fc); 
               -webkit-background-clip: text; 
               -webkit-text-fill-color: transparent;">
    DevQuest
  </span>
</h1>




> **D**riven to **E**levate **V**isions through a **Quest** of innovation, creation and exploration.

---
<h2>🧾 Portfolio Details</h2>

<pre>
👩‍🎓 Student     : <b>Shreshta S. Majalikar (SSM)</b>
🎓 SRN         : <b>01FE22BCS277</b>
🔰 Course Name : <b>Algorithmic Problem Solving (APS)</b>
🆔 Course Code : <b>24ECSE309</b>
👨‍🏫 Instructor  : <b>Prakash Hegade (PH)</b>
🌐 Domain      : <b>GOOGLE</b>
🏛 University   : <b>KLE Technological University, Hubballi </b>
</pre>



---
## 🛠️ Technical Skills

- **Languages & Frameworks**:  
  `C/C++`, `Python`, `HTML`, `CSS`, `JS`, `Node.js`, `Express.js`,`React` 
- **Databases**:  
  `SQL`, `MySQL` 
- **Tools & Platforms**:  
  `Git`, `GitHub`, `VS Code`

---

## 💼 Experience

### 🧠 **NVIDIA – Mini Project Intern** *(Oct 2024 – Jan 2025, Remote)*  
- Developed a **multimodal transformer subsystem** for **image difference estimation**, leveraging **BDD100K** dataset and **Vision Transformer (ViT)** for generating image embeddings.  
- Created a **custom dataset** using **OpenGVLab/Mini-InternVL-Chat-2B-V1-5** i.e, **Vision-Language Model (VLM)**, where the **ground truth was generated by prompting the VLM with structured questions**.


### 🚦 **NVIDIA – Minor Project Intern** *(Jan 2025 – Present, Remote)*  
- Applied a **custom demosaicing pipeline** on **RCCB sensor images** using a **CNN-based channel estimation** approach,combined with **Color Correction Matrix (CCM)** and spatial reconstruction techniques.  
- Building a **YOLOX-based traffic light detection system** by leveraging the facebook research's **Detectron2** model using the **Bosch Small Traffic Lights Dataset**.  
- Evaluating **model performance under varying lighting conditions** using data **augmentation techniques** to simulate real-world challenges.


---

## 🧪 Projects

### 🚇 **NEXUS: Metropolitan Connectivity and Commute Optimization**  
*C++ • Algorithms • DSA* | Sep 2023 – Nov 2023  
- Designed an *urban commute plan* using shortest path algorithms for smooth city connectivity.  
- Implemented **Floyd-Warshall**, **Kruskal’s**, and **Dijkstra’s** algorithms to optimize traffic flow.  
- Developed modules for *spot categorization*, *public transport access*, and *real-time route updates* and many more **commute related features** to enhance urban mobility. 

---

### 🧾 **In-Semester Assessment Management System**  
*ReactJS • Express • MySQL • CSS* | Dec 2024 – Jan 2025  
- Created a **student seating allocation system** assigning students to classrooms/labs by roll number.  
- Enabled manual adjustments by ISA coordinators and automated **question paper count**.  
- Supported export of allocations in **CSV** and **HTML** formats.  

---

### 🤖 **AI-Generated Face Detection using RvAI Classifier**  
*Machine Learning • Deep Learning* | Feb 2025  
- Built an **RvAI classifier** to detect *AI-generated faces* with high accuracy.  
- Tested extensively on real and synthetic datasets to improve model robustness.  
- Presented research at **CRM 2025 (SR University, Warangal)** and published with **Springer**.


## 🧭 Overview

<p align="center">
  <img src="https://www.gstatic.com/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png" alt="Google Logo" width="240"/>
  <br><br>
 
  <em>🧭 Glimpse into Google's Massive Service Ecosystem</em>
</p>



### 🌐 **Why Google?**

Google stands tall as a **beacon of digital evolution** — from smart searches to seamless maps, robust cloud platforms to tools that power classrooms worldwide.  
Billions depend on Google daily...  
And what powers this massive ecosystem? 🤯  
**_Brilliant algorithms working silently behind the scenes_** — and that's exactly where DevQuest dives in. 🎯

---

## 🚀 Google’s Universe of Services  
> (A curated, condensed, and clean list of Google’s major offerings 🔥)

| 🌍 **Category**              | 🚀 **Top Services**                                                                                      |
|-----------------------------|--------------------------------------------------------------------------------------------------------|
| 🔍 **Search & Discovery**    | 🔎 Google Search, 🗺️ Maps, 🌐 Translate, 📰 News, 📸 Lens                                               |
| 📧 **Communication**         | 📧 Gmail, 🎥 Google Meet, 💬 Chat, 📅 Calendar, 📞 Voice                                                |
| 📂 **Productivity Tools**    | ☁️ Drive, 📄 Docs, 📊 Sheets, 📽️ Slides, 📝 Forms, 🗒️ Keep, 🖼️ Jamboard                                 |
| 🎬 **Media & Entertainment** | ▶️ YouTube, 🎵 YouTube Music, 📺 Google TV, 🎙️ Podcasts          |
| 💳 **Payments**              | 💸 Google Pay, 💼 Wallet, 🛒 Shopping, 🏬 Google Store                                                  |
| ☁️ **Cloud & AI**             | ☁️ Google Cloud (GCP), 🤖 Gemini (Bard), 🗣️ Assistant, ⚙️ TensorFlow                                  |
| 🧠 **Developer Tools**       | 🔥 Firebase, 🤖 Android Studio, 🌐 Google Domains, 🛠️ Chrome DevTools                                 |
| 📱 **Mobile & OS**           | 🤳 Android, ⌚ Wear OS, 💻 Chrome OS, 📱 Google Pixel Apps                                             |
| 🎓 **Education**             | 🏫 Classroom, 📚 Google Scholar, 📝 Assignments                                                        |
| 🧪 **Experiments / Labs**    | 🎨 Google Arts & Culture, 🌍 Google Earth, 🧪 Experiments with Google                                  |


---
## ⚙️ Why DSA & Algorithmic Problem Solving Matter

Writing code that works is one thing. Writing code that **works fast, scales effortlessly, and handles complexity with elegance** — that’s what sets top engineering apart. That’s where **Data Structures & Algorithms (DSA)** and **Algorithmic Problem Solving (APS)** come into play.

---

### Engineering at Scale: The Google Mindset

Building for billions requires algorithmic thinking at every step. Some examples from Google’s ecosystem:

### 🔍 Search  
-Manages over 80% of the global search load. 
-Fast and relevant results rely on optimized query parsing, smart indexing (tries, inverted indices), and ranking algorithms. 
-APS helps handle intent ambiguity and large-scale data retrieval.

### 📺 YouTube  
-Over 2 billion monthly users, and more than a billion watch hours per day. 
-Behind the scenes: neural nets, collaborative filtering, and graph-based algorithms that personalize recommendations in real time.

### 📧 Gmail  
-Processes emails for 1.8 billion users. 
-Efficient spam detection, priority inbox sorting, and smart reply suggestions are all powered by Bayesian filters, classifiers, and well-optimized data pipelines.

### 🗺️ Maps  
-Used by more than a billion users. 
-Real-time traffic updates and accurate routing depend on shortest path algorithms (like Dijkstra and A*) and dynamic updates, all solved through APS techniques.

### ☁️ Google Cloud  
-Serves 9% of the global cloud market. Systems use load balancing, data sharding, and fault-tolerant architectures, all of which depend on solid DSA and performance-aware design patterns.

---

### Beyond Interviews: Building Better Systems

DSA and APS are not just for cracking interviews — they are core to building tech that:

- Scales under load  
- Performs consistently  
- Handles edge cases cleanly  
- Solves real-world complexity with clarity  

---

> **_Clean code solves problems. Smart code solves them efficiently._**


---

## 💼 Business Case Studies powered by DevQuest

# 📊 Real-World Business Case Studies from Google using DSA & APS

These case studies demonstrate how Google leverages **Data Structures and Algorithms (DSA)** and **Algorithmic Problem Solving (APS)** to solve real-world, large-scale challenges.

---

## 1. 📺 YouTube Video Load Optimization Using Caching and LRU

**Context:**  
YouTube faced high latency during video buffering, especially in areas with poor internet.

**Solution:**  
Implemented **Least Recently Used (LRU)** caching at edge servers to store frequently accessed video chunks closer to users.

**Algorithm Applied:**  
- **LRU Cache:** Doubly linked list + HashMap → O(1) access and eviction

**Benefits:**  
- Faster video start times  
- Reduced buffering  
- Lower backbone traffic

**Complexity:**  
- **Time:** O(1) for get/put  
- **Space:** O(capacity)

---

## 2. 🖼️ Google Photos Duplicate Image Detection Using Hashing & Union-Find

**Context:**  
Needed efficient detection and management of duplicate uploads across user albums.

**Solution:**  
Used **Perceptual Hashing** and **Union-Find** to cluster similar images.

**Algorithms Applied:**  
- **Hashing:** Quick image signatures  
- **Union-Find (Disjoint Set):** Grouping similar images

**Benefits:**  
- Reduced storage  
- Better search performance

**Complexity:**  
- **Hashing:** O(1) avg  
- **Union-Find:** Nearly O(1) with path compression

---

## 3. 🔍 Google Ads Keyword Matching Using Trie & Backtracking

**Context:**  
Efficiently match billions of queries with advertiser keywords including wildcard support.

**Solution:**  
Used **Trie** for prefix matching + **Backtracking** for wildcard support.

**Algorithms Applied:**  
- **Trie:** Fast prefix storage and lookup  
- **Backtracking:** Explore partial/wildcard matches

**Benefits:**  
- Accurate keyword targeting  
- Higher click-through rates

**Complexity:**  
- **Trie:** O(L) where L = keyword length  
- **Backtracking:** Optimized with pruning

---

## 4. 🎥 Google Meet Video Quality Control Using Dynamic Programming

**Context:**  
Maintain good video quality during varying network conditions.

**Solution:**  
Used **Dynamic Programming** (similar to **Knapsack Problem**) to choose optimal video resolution under bandwidth constraints.

**Algorithm Applied:**  
- **DP Optimization:** Choose best bitrate/resolution combination

**Benefits:**  
- Stable video on poor connections  
- Smart bandwidth use

**Complexity:**  
- **Time:** O(nW), where `n = levels`, `W = bandwidth`

---

## 5. 🔠 Google Search Autocorrect Using Edit Distance & Trie

**Context:**  
Fix misspelled queries and suggest the right search terms in real-time.

**Solution:**  
Used **Edit Distance (Levenshtein)** and **Trie** for spelling correction and suggestions.

**Algorithms Applied:**  
- **Edit Distance:** Minimum edit transformation  
- **Trie:** Efficient word suggestions from dictionary

**Benefits:**  
- Accurate autocorrect  
- Improved search UX

**Complexity:**  
- **Edit Distance:** O(mn), where `m` and `n` are word lengths  
- **Trie:** O(L) where `L = word length`

---


# 🚀 Google Algorithmic Use Cases: Optimized Solutions for Core Problems

Welcome to the **Google Algorithmic Use Cases** repository! This document aims to present an insightful and comprehensive overview of the fundamental algorithmic problems Google leverages to power its wide array of services — from ad placement optimization and secure data management to predictive text input and cryptographic security. Each algorithmic use case is carefully dissected with explanations on its **real-world application at Google**, its **algorithmic complexity** (both time and space), **visual representations** to clarify concepts, and direct links to working **code implementations** that you can explore, learn from, and contribute to.

---

## 1. Optimizing Google Ads Allocation with the Assignment Problem 🎯

**Overview:**  
Google Ads plays a critical role in Google's business model, requiring highly efficient assignment of advertisements to available display slots on search result pages or partner sites. The goal is to maximize overall **revenue generation** while also enhancing **user engagement** by showing the most relevant ads to the right audience.

The underlying challenge maps perfectly onto the classical **Assignment Problem**, where we treat ads and slots as two disjoint sets in a bipartite graph. Each edge carries a "weight" representing the predicted click-through rate (CTR) or potential revenue if a specific ad is placed in a given slot.

**Application:**  
Google employs the **Hungarian Algorithm**, a combinatorial optimization algorithm, to find the perfect matching between ads and slots such that the total CTR is maximized. This approach ensures an optimal pairing without exhaustive search, providing scalability for millions of ads and slots daily.

- ⏳ **Time Complexity:** The Hungarian Algorithm runs in cubic time — O(n³), where *n* is the number of ads or slots. While seemingly costly, various heuristics and parallelization make it practical for large-scale ad auctions.  
- 🧠 **Space Complexity:** Requires O(n²) space to store the cost matrix representing all possible ad-slot pairings.

**Visual Representation:**  
Imagine a bipartite graph with two columns: Ads on the left, slots on the right. Edges between them have weights showing predicted CTRs. The Hungarian Algorithm finds a perfect matching maximizing the sum of selected edges.

![Assignment Problem](https://example.com/assignment_problem_image.png)

**Code Snippet:**  
Explore the full implementation with detailed comments here:  
[Assignment Problem Implementation](https://github.com/yourusername/assignment-problem)

---

## 2. Enhancing Data Security with the Stolen Values Problem 🔒

**Overview:**  
Data security and integrity are paramount for Google’s vast infrastructure. Sometimes, datasets may become partially corrupted or certain values may be "stolen" or tampered with due to malicious activities or transmission errors. The **Stolen Values Problem** focuses on reconstructing the original, untampered dataset as accurately as possible from incomplete or inconsistent data.

**Application:**  
Google uses sophisticated **Dynamic Programming (DP)** techniques to reconstruct or estimate the original data. The DP approach minimizes the cumulative difference between reconstructed and observed values, ensuring data integrity and robustness against partial theft or corruption.

- ⏳ **Time Complexity:** Linear in the number of data points, O(n), ensuring efficient reconstruction even for massive datasets.  
- 🧠 **Space Complexity:** Also O(n), storing intermediate reconstruction states.

**Visual Representation:**  
Envision a timeline of data points, some marked as missing or suspect. The DP algorithm iteratively fills in gaps by balancing consistency and minimizing discrepancies.

![Stolen Values Problem](https://example.com/stolen_values_image.png)

**Code Snippet:**  
Check out the reconstruction algorithm implementation here:  
[Stolen Values Problem Implementation](https://github.com/yourusername/stolen-values-problem)

---

## 3. Predicting User Behavior with Ways to Reach a Number 🔢

**Overview:**  
Understanding how users navigate through a sequence of actions (like clicks or page visits) helps Google optimize user experience and site architecture. Modeling the number of distinct paths to reach a particular "state" or goal action provides insight into user behavior and funnel effectiveness.

**Application:**  
This problem is conceptually similar to the **coin change problem** in algorithm design. Using **Dynamic Programming**, Google calculates the number of unique sequences (paths) by which a user can reach a target action, accounting for different "step sizes" or intermediate interactions.

- ⏳ **Time Complexity:** O(n × m), where *n* is the target number (or goal action) and *m* is the number of possible step sizes or intermediate actions.  
- 🧠 **Space Complexity:** O(n), maintaining counts for each reachable intermediate state.

**Visual Representation:**  
Think of a step diagram where each step size represents a jump from one user action to the next, and the DP table accumulates ways to reach the goal.

![Ways to Reach a Number](https://example.com/ways_to_reach_number_image.png)

**Code Snippet:**  
Dive into the DP solution here:  
[Ways to Reach a Number Implementation](https://github.com/yourusername/ways-to-reach-number)

---

## 4. Improving Search Suggestions with Longest Common Subsequence (LCS) 🔍

**Overview:**  
Search engines thrive on giving users fast, relevant suggestions. The **Longest Common Subsequence (LCS)** algorithm helps by measuring the similarity between the user’s input string and popular search queries, identifying common subsequences that may indicate user intent.

**Application:**  
Google’s autocomplete features use LCS to find the longest common subsequence between a user's partial input and candidate queries in the database, thereby ranking and suggesting the most relevant completions.

- ⏳ **Time Complexity:** O(m × n), where *m* and *n* are lengths of the input strings.  
- 🧠 **Space Complexity:** O(m × n), for the DP matrix used to compute LCS.

**Visual Representation:**  
A matrix showing comparison between two strings where LCS cells are filled progressively, highlighting the longest subsequence.

![Longest Common Subsequence](https://example.com/lcs_image.png)

**Code Snippet:**  
View the full LCS implementation:  
[Longest Common Subsequence Implementation](https://github.com/yourusername/longest-common-subsequence)

---

## 5. Auto-Correct Feature Enhancement with Longest Common Substring ✍️

**Overview:**  
Google's auto-correct function improves typing accuracy by detecting the longest common substring between potentially misspelled words and dictionary entries, thus suggesting the closest valid words.

**Application:**  
By finding the longest continuous matching sequence of characters (substring) between user input and dictionary words, Google can prioritize corrections that require minimal editing, enhancing typing efficiency and reducing errors.

- ⏳ **Time Complexity:** O(m × n), with *m* and *n* being the lengths of the two strings compared.  
- 🧠 **Space Complexity:** O(m × n) to store intermediate results in DP tables.

**Visual Representation:**  
A grid showing character comparisons, where contiguous matches form the longest substring highlighted in color.

![Longest Common Substring](https://example.com/lcs_substring_image.png)

**Code Snippet:**  
Explore the substring detection code here:  
[Longest Common Substring Implementation](https://github.com/yourusername/longest-common-substring)

---

## 6. Optimizing Resource Allocation with the Knapsack Problem 🎒

**Overview:**  
In Google Cloud, allocating limited computational resources like CPU time, memory, and bandwidth to numerous client tasks requires optimal strategies to maximize overall system performance and client satisfaction.

**Application:**  
The classical **Knapsack Problem** helps decide which set of tasks to run, balancing their benefits (profits) against their resource demands (weights), ensuring the total resource consumption doesn't exceed capacity while maximizing the profit.

- ⏳ **Time Complexity:** O(n × W), where *n* is the number of tasks and *W* is the total resource capacity.  
- 🧠 **Space Complexity:** O(n × W), maintaining DP tables of possible weight-profit combinations.

**Visual Representation:**  
A table or graph visualizing inclusion/exclusion of tasks with respect to capacity and total profit.

![Knapsack Problem](https://example.com/knapsack_problem_image.png)

**Code Snippet:**  
Check out the knapsack solver here:  
[Knapsack Problem Implementation](https://github.com/yourusername/knapsack-problem)

---

## 7. Enhancing Data Analysis with Subset Sum Problem 📊

**Overview:**  
Detecting subsets within large datasets that sum to a particular target is important for identifying anomalies, patterns, or targeted data segments in Google’s analytics pipelines.

**Application:**  
The **Subset Sum Problem** algorithm identifies these subsets, enabling effective segmentation and anomaly detection by pinpointing data combinations meeting specific criteria.

- ⏳ **Time Complexity:** O(n × sum), where *sum* is the target sum value and *n* is the number of elements.  
- 🧠 **Space Complexity:** O(n × sum), storing DP tables for subsets and sums.

**Visual Representation:**  
Visualizes subset selection as a binary decision tree or a DP table illustrating sums achievable by subsets.

![Subset Sum Problem](https://example.com/subset_sum_image.png)

**Code Snippet:**  
See the subset sum algorithm here:  
[Subset Sum Problem Implementation](https://github.com/yourusername/subset-sum-problem)

---

## 8. Predictive Text Input with Coin Combinations ✨

**Overview:**  
Google’s predictive text systems estimate all possible word or phrase formations given partial input, improving typing speed and accuracy.

**Application:**  
The **Coin Combinations** approach calculates how many ways input letters can combine into valid words, enhancing prediction accuracy in keyboards and search bars.

- ⏳ **Time Complexity:** O(n × m), where *n* is the input length and *m* is the number of possible tokens or letters.  
- 🧠 **Space Complexity:** O(n), storing number of combinations up to each input length.

**Visual Representation:**  
A staircase diagram showing incremental combinations formed at each character addition.

![Coin Combinations](https://example.com/coin_combinations_image.png)

**Code Snippet:**  
Explore the coin combinations code here:  
[Coin Combinations Implementation](https://github.com/yourusername/coin-combinations)

---

## 9. Strengthening Cryptographic Systems with the Coin Change Problem 🔐

**Overview:**  
Google’s security systems sometimes use cryptographic algorithms that rely on optimal partitioning of values, similar to the coin change problem, for efficient encoding and decoding.

**Application:**  
This problem helps determine the minimum number of coins (units) required to make change for a certain amount, analogous to minimizing operations in cryptographic protocols.

- ⏳ **Time Complexity:** O(n × m), where *n* is the amount and *m* is the number of coin denominations.  
- 🧠 **Space Complexity:** O(n), for DP arrays storing minimum coins needed.

**Visual Representation:**  
A DP array where each index represents the minimal coins needed for that amount.

![Coin Change Problem](https://example.com/coin_change_image.png)

**Code Snippet:**  
View the coin change solution here:  
[Coin Change Problem Implementation](https://github.com/yourusername/coin-change-problem)

---




### References

- [Assignment Problem & Dynamic Programming - 33rd Square](https://www.33rdsquare.com/ase-studies-10x-faster-using-dynamic-programming/?utm_source=chatgpt.com)  
- [Google AI Optimization - WIRED](https://www.wired.com/story/google-vizier-black-box-optimisation-machine-learning-cookies?utm_source=chatgpt.com)

---


> 👣 **Let DevQuest continue...** Stay tuned for deeper case studies and solutions in this exploration of how algorithms quietly shape the tech we rely on daily.







































<!--commeneted-->
<!--### 📦 *Google’s Universe of Services*
> (A curated list of major services under the Google umbrella — structured, spaced, and sparkling ✨)

<br/>
---

### 🔍 *Search & Discovery*
- *Google Search* 🌐 – Your gateway to the world’s information.
- *Google Maps* 🗺 – Navigate the planet with precision and ease.
- *Google Translate* 🌍 – Break language barriers instantly.
- *Google News* 📰 – Curated headlines from around the globe.
- *Google Lens* 🔎 – Visual search that sees the world like you do.

---

### 📧 *Communication & Collaboration*
- *Gmail* 📬 – Fast, secure, and smart email.
- *Google Meet* 🎥 – High-quality video conferencing.
- *Google Chat* 💬 – Smart messaging for teams and individuals.
- *Google Calendar* 📅 – Plan, schedule, and never miss a beat.

---

### 📂 *Productivity & Cloud Tools*
- *Google Drive* ☁ – Store, sync, and share your files.
- *Google Docs* 📝 – Real-time collaborative writing.
- *Google Sheets* 📊 – Analyze and visualize data together.
- *Google Slides* 🎞 – Beautiful presentations, made easy.
- *Google Forms* 🧾 – Surveys, polls, and quizzes in seconds.
- *Google Keep* 🗒 – Notes and lists, synced across devices.
- *Google Workspace* 🧑‍💻 – Your productivity suite in one place.

---

### 🎬 *Media & Entertainment*
- *YouTube* 📹 – Watch, upload, and connect through videos.
- *YouTube Music* 🎧 – Music streaming tailored to you.
- *Google Podcasts* 🎙 – Discover and listen to top podcasts.

---

### 💳 *Payments & Shopping*
- *Google Pay* 💸 – Fast, secure digital payments.
- *Google Wallet* 👛 – All your cards, tickets, and IDs in one app.
- *Google Shopping* 🛍 – Smart product discovery and deals.

---

### ☁ *Cloud & AI*
- *Google Cloud Platform (GCP)* ☁ – Scalable cloud services for devs and enterprises.
- *Gemini (formerly Bard)* 🤖 – Conversational AI and productivity assistant.
- *Google Assistant* 🎙 – Voice-powered help, wherever you go.

---

### 🎓 *Learning & Education*
- *Google Classroom* 🎓 – Organize classes, assignments, and grades easily.
-->
