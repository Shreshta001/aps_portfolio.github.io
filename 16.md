# âš™ï¸ **Multiplicative Modular Inverse and Extended Euclidean Algorithm**

Modular inverses are crucial in many algorithms, especially when the modulus is **not prime**. While Fermatâ€™s Little Theorem works beautifully for prime moduli, the **Extended Euclidean Algorithm** offers a powerful and flexible way to find modular inverses for **any modulus** â€” prime or not.

---

## ğŸŒ Application in Google Systems

Google applies the Extended Euclidean Algorithm in various unique and impactful ways:

| Use Case                       | How Extended Euclidean Algorithm Helps                                 |
|-------------------------------|------------------------------------------------------------------------|
| ğŸ” **Cryptography Beyond Primes** | Computes modular inverses in cryptographic systems using composite moduli |
| ğŸ› ï¸ **Error Correction Codes**     | Used in Reed-Solomon and other ECC algorithms for data integrity          |
| ğŸ§® **Distributed Systems**        | Calculates inverses for modular arithmetic in fault-tolerant consensus   |
| ğŸ§© **Custom Hash Functions**      | Enables modular inverses for hashing schemes with non-prime moduli       |
| âš™ï¸ **Optimization in Compiler Backends** | Helps solve modular equations arising in register allocation and instruction scheduling |

---

## ğŸ“ Visual Representation

<p align="center">
  <img 
    src="https://media.geeksforgeeks.org/wp-content/uploads/20241029175726314002/Extended-Euclid-Division-Algorithm--1.webp" 
    alt="Extended Euclidean Algorithm Visualization" 
    width="70%" 
    style="border: 2px solid #555; border-radius: 12px; padding: 5px;">
</p>

<figcaption style="text-align: center; font-style: italic;">
  Figure: Stepwise calculation of GCD and modular inverse using the Extended Euclidean Algorithm
</figcaption>

<br/>

- **Key Idea:**  
  The algorithm recursively finds integers *x* and *y* such that:  
  > a Ã— x + b Ã— y = gcd(a, b)  
  When gcd(a, b) = 1, *x* is the modular inverse of *a* modulo *b*.

---

## âš™ï¸ Algorithmic Insight

The Extended Euclidean Algorithm efficiently computes:

- The **greatest common divisor (GCD)** of two integers *a* and *b*  
- Coefficients *x* and *y* satisfying BÃ©zout's identity:  
  > aÃ—x + bÃ—y = gcd(a, b)  

If gcd(a, b) = 1, then *x* is the modular inverse of *a* modulo *b*.

### ğŸ“ˆ Complexity

| Metric             | Value             | Description                                  |
|--------------------|-------------------|----------------------------------------------|
| â³ Time Complexity  | `O(log min(a, b))` | Number of recursive steps proportional to log of smaller input |
| ğŸ§  Space Complexity | `O(1)`            | Uses constant extra space for variables       |

---

## ğŸ§‘â€ğŸ’» Code Reference

ğŸ‘‰ [Extended Euclidean Algorithm Implementation](https://github.com/Shreshta001/aps_portfolio.github.io/blob/main/codes/16.cpp)

---

## ğŸ§  Fun Fact

- Unlike Fermatâ€™s Little Theorem, the Extended Euclidean Algorithm works even when the modulus isnâ€™t prime â€” making it indispensable for many practical systems.  
- Googleâ€™s storage systems and cryptographic protocols rely on it to maintain **robustness** and **flexibility** in modular arithmetic.  
- It also underpins many algorithmic solutions in **optimization** and **coding theory**, such as solving linear Diophantine equations efficiently.

---

## ğŸ“š References

- Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C., *Introduction to Algorithms*  
- [Wikipedia: Extended Euclidean Algorithm](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)  
- Google Research: Modular Arithmetic in Distributed Systems  

---

[â¬… back to home](./README.md)
